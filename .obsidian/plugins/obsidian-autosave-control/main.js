/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var S=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var F=Object.prototype.hasOwnProperty;var V=(o,e)=>{for(var t in e)S(o,t,{get:e[t],enumerable:!0})},D=(o,e,t,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of b(e))!F.call(o,i)&&i!==t&&S(o,i,{get:()=>e[i],enumerable:!(s=x(e,i))||s.enumerable});return o};var G=o=>D(S({},"__esModule",{value:!0}),o);var M={};V(M,{AutoSaveController:()=>m,DEFAULT_SETTINGS:()=>I,default:()=>f});module.exports=G(M);var L=require("obsidian");var g=class{constructor(e){this.plugin=e}attach(){this.el=this.plugin.addStatusBarItem(),this.el.setText("\u25CF"),this.el.addClass("save-status-icon"),this.setAllSaved()}setPending(e){this.el&&(e>0?(this.el.classList.remove("asc-saved"),this.el.classList.add("asc-pending"),this.el.setAttribute("title","Changes pending save")):this.setAllSaved())}setAllSaved(){this.el&&(this.el.classList.remove("asc-pending"),this.el.classList.add("asc-saved"),this.el.setAttribute("title","All changes saved"))}};var d=require("obsidian"),w=class extends d.PluginSettingTab{constructor(t,s){super(t,s);this.host=s}display(){var s,i,h,n,v,p;let{containerEl:t}=this;t.empty(),t.createEl("h2",{text:"Autosave Control"}),new d.Setting(t).setName("Save interval (seconds)").setDesc("Delay before autosave is written (3\u20133600).").addText(a=>a.setValue(String(this.host.settings.saveInterval)).onChange(async r=>{let l=parseInt(r,10);isNaN(l)&&(l=10),l=Math.max(3,Math.min(3600,l)),this.host.settings.saveInterval=l,await this.host.saveSettings()})),(h=(i=(s=new d.Setting(t).setName("Saved color").setDesc("Status dot color when all changes are saved.")).addColorPicker)==null?void 0:i.call(s,a=>a.setValue(this.host.settings.savedColor).onChange(async r=>{this.host.settings.savedColor=r,await this.host.saveSettings(),this.host.applyColors()})))!=null||new d.Setting(t).setName("Saved color (hex)").addText(a=>a.setValue(this.host.settings.savedColor).onChange(async r=>{this.host.settings.savedColor=r,await this.host.saveSettings(),this.host.applyColors()})),(p=(v=(n=new d.Setting(t).setName("Pending color").setDesc("Status dot color when saves are pending.")).addColorPicker)==null?void 0:v.call(n,a=>a.setValue(this.host.settings.pendingColor).onChange(async r=>{this.host.settings.pendingColor=r,await this.host.saveSettings(),this.host.applyColors()})))!=null||new d.Setting(t).setName("Pending color (hex)").addText(a=>a.setValue(this.host.settings.pendingColor).onChange(async r=>{this.host.settings.pendingColor=r,await this.host.saveSettings(),this.host.applyColors()}))}};var u=require("obsidian");var P=(...o)=>{};var I={saveInterval:10,savedColor:"#32cd32",pendingColor:"#00bfff"},y=new Map,f=class extends L.Plugin{constructor(){super(...arguments);this.styleEl=null}async onload(){this.settings=Object.assign({},I,await this.loadData()),this.status=new g(this),this.status.attach(),this.controller=new m(this.app,()=>this.settings),this.controller.setPendingCallback(t=>this.status.setPending(t)),this.controller.apply(),this.installStyle(),this.applyColors(),this.addSettingTab(new w(this.app,this))}onunload(){this.controller.restore(),this.styleEl&&(this.styleEl.remove(),this.styleEl=null)}async saveSettings(){await this.saveData(this.settings)}applyColors(){let t=document.documentElement;t.style.setProperty("--asc-saved-color",this.settings.savedColor),t.style.setProperty("--asc-pending-color",this.settings.pendingColor)}installStyle(){if(this.styleEl)return;let t=`
      .save-status-icon.asc-saved   { color: var(--asc-saved-color,   #32cd32); }
      .save-status-icon.asc-pending { color: var(--asc-pending-color, #00bfff); }
    `,s=document.createElement("style");s.setAttribute("data-asc","styles"),s.textContent=t,document.head.appendChild(s),this.styleEl=s}},c=(...o)=>P("[asc]",...o),k=2100,A=new WeakSet,m=class{constructor(e,t){this.origSave=null;this.unloading=!1;this.pending=new Map;this.windowEnd=new Map;this.token=new Map;this.app=e,this.getSettings=t}setPendingCallback(e){this.onPendingChange=e}apply(){if(this.origSave)return;let e=u.MarkdownView.prototype;this.origSave=e.save,e.save=this.makeWrapper(e.save);let t=()=>this.markActiveFileInput(!0);this.onBeforeUnload=()=>{this.unloading=!0},window.addEventListener("beforeunload",this.onBeforeUnload,{capture:!0}),this.onInput=t,this.onPaste=t,this.onCut=t,window.addEventListener("input",this.onInput,!0),window.addEventListener("paste",this.onPaste,!0),window.addEventListener("cut",this.onCut,!0),this.app.workspace.on("active-leaf-change",s=>{!s||!(s.view instanceof u.MarkdownView)||this.attachWindowListeners(activeWindow)}),this.attachWindowListeners(window),c("wrapped save and attached listeners")}attachWindowListeners(e){if(A.has(e))return;let t=()=>this.markActiveFileInput(!0),s=i=>{["Enter","Backspace","Delete"].includes(i.key)&&t()};e.addEventListener("keydown",s,!0),e.addEventListener("input",t,!0),e.addEventListener("paste",t,!0),e.addEventListener("cut",t,!0),e.addEventListener("beforeunload",()=>this.flushAllPending()),A.add(e)}markActiveFileInput(e=!1){var i;let t=this.app.workspace.getActiveViewOfType(u.MarkdownView),s=(i=t==null?void 0:t.file)==null?void 0:i.path;s&&(y.set(s,Date.now()),e&&c("input made:",s))}async flushAllPending(){let e=Array.from(this.pending.keys());for(let t of e)await this.flush(t)}restore(){let e=u.MarkdownView.prototype;this.origSave&&(e.save=this.origSave,this.origSave=null),this.onBeforeUnload&&window.removeEventListener("beforeunload",this.onBeforeUnload,{capture:!0}),this.onInput&&window.removeEventListener("input",this.onInput,!0),this.onPaste&&window.removeEventListener("paste",this.onPaste,!0),this.onCut&&window.removeEventListener("cut",this.onCut,!0),this.onBeforeUnload=this.onInput=this.onPaste=this.onCut=void 0,c("restored save")}makeWrapper(e){let t=this;return function(...i){var l,C;let h=this.file,n=h==null?void 0:h.path;if(c("wrapped Save called:"+n+"/"+h),!n)return e.apply(this,i);let v=Date.now(),p=(l=y.get(n))!=null?l:0,a=v-p;c(n+":since:"+a);let r=a>=0&&a<=k;if(t.unloading)return t.clearPending(n),t.windowEnd.delete(n),t.token.delete(n),e.apply(this,i);if(r){let T=(C=t.windowEnd.get(n))!=null?C:0,E=t.token.get(n);if(v<=T&&(E!==void 0&&E===p))return t.clearPending(n),t.windowEnd.delete(n),t.token.delete(n),e.apply(this,i);t.defer(n,this),t.windowEnd.set(n,p+k),t.token.set(n,p);return}return t.clearPending(n),t.windowEnd.delete(n),t.token.delete(n),e.apply(this,i)}}markInput(e){y.set(e,Date.now())}defer(e,t){let s=this.pending.get(e);s&&clearTimeout(s.timeoutId);let i=window.setTimeout(()=>this.flush(e),this.getSettings().saveInterval*1e3);this.pending.set(e,{file:t.file,view:t,timeoutId:i}),this.emitPending()}async flush(e){let t=this.pending.get(e);!t||!this.origSave||(clearTimeout(t.timeoutId),this.pending.delete(e),this.emitPending(),await this.origSave.call(t.view),this.windowEnd.delete(e),this.token.delete(e),c("flushed",e))}clearPending(e){let t=this.pending.get(e);t&&(clearTimeout(t.timeoutId),this.pending.delete(e),this.emitPending())}emitPending(){var e;(e=this.onPendingChange)==null||e.call(this,this.pending.size)}};
